use super::request::*;
use serde::{Deserialize, Serialize};
use serde_json::Value;

#[derive(Serialize, Deserialize, Clone, Debug)]
#[allow(non_camel_case_types)]
pub enum FinishReason {
    /// Default value. This value is unused.
    FINISH_REASON_UNSPECIFIED,
    /// Natural stop point of the model or provided stop sequence.
    STOP,
    /// The maximum number of tokens as specified in the request was reached.
    MAX_TOKENS,
    /// The response candidate content was flagged for safety reasons.
    SAFETY,
    /// The response candidate content was flagged for recitation reasons.
    RECITATION,
    /// The response candidate content was flagged for using an unsupported language.
    LANGUAGE,
    /// Unknown reason.
    OTHER,
    /// Token generation stopped because the content contains forbidden terms.
    BLOCKLIST,
    /// Token generation stopped for potentially containing prohibited content.
    PROHIBITED_CONTENT,
    /// Token generation stopped because the content potentially contains Sensitive Personally Identifiable Information (SPII).
    SPII,
    /// The function call generated by the model is invalid.
    MALFORMED_FUNCTION_CALL,
    /// Token generation stopped because generated images contain safety violations.
    IMAGE_SAFETY,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
#[allow(non_snake_case)]
struct Candidate {
    content: Chat,
    pub finishReason: Option<FinishReason>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
#[allow(non_snake_case)]
pub struct GeminiResponse {
    candidates: Vec<Candidate>,
    pub usageMetadata: Value,
    pub modelVersion: String,
    pub promptFeedback: Option<Value>,
}

impl GeminiResponse {
    pub(crate) fn new(response: minreq::Response) -> Result<GeminiResponse, minreq::Error> {
        response.json()
    }
    pub fn get_parts(&self) -> &Vec<Part> {
        self.candidates[0].content.parts()
    }
    ///`seperator` used to concatenate all text parts. TL;DR use "" as seperator.
    pub fn extract_text(parts: &[Part], seperator: impl AsRef<str>) -> String {
        let mut concatenated_string = String::new();
        for part in parts {
            let Part::text(text) = part;
                concatenated_string.push_str(text);
                concatenated_string.push_str(seperator.as_ref());
        }
        concatenated_string
    }
    ///`seperator` used to concatenate all text parts. TL;DR use "" as seperator.
    pub fn get_text(&self, seperator: impl AsRef<str>) -> String {
        Self::extract_text(self.get_parts(), seperator.as_ref())
    }
}